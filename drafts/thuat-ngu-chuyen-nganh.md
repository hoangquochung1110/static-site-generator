Bàn về thuật ngữ chuyên ngành.
---------------------------------
Chào mọi người, mình là người thích gì viết đó đây. Hôm nay mình sẽ bàn về những thuật ngữ mà mình tìm hiểu được. Vì cũng tự mình tìm hiểu nên có thể sai sót, nhờ mọi người góp ý, bổ sung thêm giúp mình ạ.
Đầu tiên ta có data at rest:
- Theo mình hiểu thì nó là trạng thái nghỉ ngơi của data. Tức là data nằm yên một chỗ mà không bị di dời. Ví dụ ta có data encryption at rest nghĩa là data được mã hóa trong trạng thái nằm yên trong cơ sở dữ liệu.
Cùng với data at rest, chúng ta có data in transit, nghĩa là data đang được vận chuyển từ chỗ này sang chỗ khác, có thể là database A sang cơ sở dữ liệu hoặc backup chẳng hạn, nhưng ở đây chủ yếu đề cập về quá trình di chuyển của data. Chẳng hạn ta có data encryption in transit nghĩa là quá trình vận chuyển này, data được bảo vệ bằng cách mã hóa.
SSL/TLS:
Chúng ta biết giao thức cơ bản nhất để giao tiếp là giao thức TCP, SSL dùng để bảo vệ ở tầng TCP layer 4. Kế thừa giao thức này, người ta tạo ra giao thức http nhằm truyền tải dữ liệu siêu văn bản. Sự khác biệt là http có dùng thêm nhiều các header để giao tiếp với nhau. Nhưng mà như vậy thì khi giao tiếp có nguy cơ bị lộ thông tin nếu như hacker bắt được gói tin này. Vì SSL là dùng để bảo vệ cho TCP, nên sau này người ta custom thêm một tí để giúp nó bảo vệ cho giao thức http, và họ đặt tên là TLS. Nhưng bây giờ, khi nói là SSL thì mọi người đều cũng hiểu là TLS luôn vì thế họ hay gọi là SSL/TLS.
Để bàn tiếp về SSL chúng ta sẽ bàn về mã hóa một tí. Chúng ta có hai cách mã hóa là mã hóa bất đối xứng (asymetric) và mã hóa đối xứng symetric key.
Symetric key là chúng ta sử dụng một key để thực hiện cho việc mã hóa và giải mã. Bên phía server sẽ cầm key này để mã hóa gói tin nhưng làm thế nào để client của chúng ta giải mã được đây. Việc gửi key này tới phía client không khả thi vì có thể web chúng ta nhiều user sử dụng, giả sử 1000 người thì chúng ta phải gửi 1000 lần mà 1000 key này nó phải khác nhau vì nếu không người này sẽ giải mã được thông tin người khác và chưa kể đến client cũng có thể làm lộ cái key này nữa. Vì thế, mỗi lần gửi văn bản, người ta phải gửi văn bản đã được mã hóa bằng key này, sau đó gen một key tạm thời sau đó gửi kèm với văn bản qua phía client để người ta giải mã. Nhưng mà có rủi ro là hacker có thể bắt được gói tin chứa key này và giải mã gói tin của chúng ta. Việc này rất nguy hiểm.
Asymetric key là việc chúng ta sử dụng hai key, gồm public key và private key. Public key chuyên dùng để mã hóa và private key chuyên dùng để giải mã, để tính được key này họ dùng ngẫu nhiên một số nguyên tố vô cùng lớn rồi mod lại, các bạn có thể đọc kĩ hơn ở tài liệu trên mạng. Về mã hóa này thì phía server sẽ giữ private rất kĩ và sau đó gửi public key qua cho client và từ đó client dùng public key này để mã hóa thông tin rồi gửi về lại server, server dùng gói tin này để giải mã. Nhưng mà client gửi về cho server được rồi vậy thì server gửi cho client thì làm sao client giải mã đây, không lẽ phải gửi riêng private key cho client thì lại gặp lại vấn đề ở trên là mỗi người phải có một private key riêng nhưng 1000 người thì lại lặp lại vấn đề ban nãy. Thế còn việc bên phía client tự generate một cặp key thì sao, sau đó gửi public key qua server và từ đó server dùng public key này để mã hóa rồi gửi lại client. Về lý thuyết nó an toàn, nhưng lại lặp lại vấn đề 1000 người với 1000 key khác nhau... Điều này tốn nhiều công sức.
Rồi tự nhiên mọi người lại nảy ra, sao không ứng dụng cả asymetric key và symetric key nhỉ. Và từ đó HTTPS ra đời, gọi là https vì http có secure và sử dụng SSL/TLS để mã hóa và dùng dựa trên chuẩn chung X509. Về flow nó thì bên phía server sẽ generate một cặp key public và private, dùng mã hóa asymetric. Sau đó, server sẽ gửi public key về phía client. Bên phía client sẽ tự động generate ra một symetric key, vì tự gen nên họ đã có sẵn symetric key rồi và nó có thời hạn timeout cho một session. Và dùng public key mã hóa để gửi cái symetric này về phía server, server sẽ dùng symetric key này để trao đổi thông tin với phía client và không cần phải gửi kèm key nữa. Và key này do client generate ra nên khi trao đổi thông tin xong thì key này hết hạn và không chấp nhận trao đổi key nữa. Vì thế rất an toàn.
Về symetric và asymetric key chúng ta có thể sử dụng dịch vụ aws KMS. KMS là một serverless, nghĩa là aws đã set up hết cho chúng ta rồi và chúng ta chỉ việc vào đó sử dụng và tự tạo symetric hoặc asymetric key. Ngoài ra, nếu chúng ta muốn tự quản lý server, chúng ta có thể sử dụng dịch vụ cloud hsm để tự giúp tự host server nhằm can thiệp sâu hơn.
Self-sign certificate
Đây là chứng chỉ tự ký, ký bằng cơm, chúng ta có thể sử dụng openssl để ký symetric hoặc asymetric key. Quay lại bài toán ở trên, chúng ta cần một cặp key asymetric nhưng mà vấn đề là một lần rotate key này chúng ta có thể tự ký bằng tool openssl hoặc tool nào đó hỗ trợ ký https và thường key này sẽ không được tin cậy vì chúng ta tự ký mà giờ validate bằng cách nào. Nói về cơ chế validate key thì chúng ta sử dụng trusted certificate store để trust certificate authority. Về việc này chúng ta có thể dùng open ssl để làm lab.
Certificate authority
Đây là một server based framework dùng để quản lý certificate, nó hoạt động dựa trên mô hình PKI (public key infrastructure). Nghĩa là họ đã lập trình sẵn và expose ra các api chứa các function ký các chứng chỉ cho chúng ta trên con server này rồi, việc chúng ta là chỉ cần call tới api để sử dụng thay vì ký bằng cơm. Nhưng làm thế nào để server biết được chúng ta là ai, chúng ta là người nào mà cấp đúng chứng chỉ cho chúng ta đây. Lỡ lần này chúng ta xin server cấp cho chúng ta, nhưng lần sau rotate người khác xin, làm sao server định danh chúng ta được? Vì thế chúng ta phải tạo CSR (certificate signing request), mục đích chính là để server biết chúng ta là ai, sau này chúng ta cứ cầm cái csr này để request thôi. Về lý thuyết 1 máy các bạn tạo nhiều cũng được, nhưng đừng để lộ CSR nếu không sẽ bị ảnh hưởng tới việc validation. Vì họ có thể dùng CSR để giả mạo danh tính của bạn, từ đó yêu cầu server rotate lại certificate hoặc issue lại certificate mới. Các bạn có thể làm lab trên linux bằng cách dùng step CA, hoặc sử dụng window server để tạo certificate authority để test demo nhé. Ngoài ra, trên thế giới có các tổ chức miễn phí nhiều lắm ví dụ như let encryption để issue cert. Các bạn có thể dùng tool tên là cert bot để request tới tổ chức let enccyption để lấy certification về nhé. Ngoài ra nó có tích hợp với nginx, http và các dịch vụ web thông thường để tự động cấu hình ssl cho chúng ta luôn. Làm lab ở cloud chúng ta có thể sử dụng dịch vụ ACM để tự dựng public hoặc private CA các bạn nhé.
Mô hình chain of trust
Giả sử chúng ta có certificate authority. Nó sẽ phân cấp theo thứ tự là root rồi tới surbordinate dưới surbodinate là có cacs surbodinate con nữa, tùy cách chúng ta chia. Nhưng mà đại khái là cấp trên và cấp dưới. Thì khi các bạn trust cấp trên thì mặc định trust luôn các nhóm cấp dưới. Nhưng mà trust cấp dưới thì trust cấp dưới hơn nhưng mà không trust cấp trên.
Mutual SSL
Ý tưởng là chúng ta sẽ cấu hình server trust một certificate authority, trust certificate authority nghĩa là trust chữ ký của authority này. Nhưng mà mutual ở đây nó dùng cái chữ ký của authority này để định danh người dùng thay vì dùng username và password. Nghĩa là tất cả các cert issue bởi server authority này sẽ được hiểu là từ một người. Tiêu biểu của việc sử dụng mutual SSL cho việc SSO là sử dụng giao thức kerberos authentication. Về mutual ssl mình thấy thường dùng cho K8S, các dịch vụ IOT, hoặc là  database authentication. Ngoài lề tí, chúng ta có thể sử dụng trick là cấu hình một con server để làm việc authentication, sau đó login ở server này rồi mount key này vào trong 100 con server khác. Việc này giúp chúng ta chỉ login 1 chỗ thôi nhưng 100 server tự động authen. Có thể nó có thể có ích trong việc triển khai microservice của các bạn khi yêu cầu không được authen tại chính server đó. Việc này cũng tương tự service account của k8s hoặc sts assume của aws.
DNS
Đây là hệ thống phân giải tên miền. Mạng máy tính chủ yếu sử dụng địa chỉ IP nhưng mà như vậy rất khó nhớ. Từ đó họ sử dụng DNS để dịch từ một tên nào đó bằng chữ cái sang địa chỉ IP. Ví dụ google là 8.8.8.8 chẳng hạn. Chúng ta có thể tự cấu hình dns bằng cách vào chỉnh ở file host trên máy tính.
DNS Server
Việc mà chỉnh file host vậy đâu có share chung được và cũng không thể nào dùng làm domain nhiều level ví dụ như subdomain chẳng hạn. Vì thế, thay vì dùng bằng cơm, họ lại tạo ra một cái server và expose ra các api để chúng ta dùng cho dễ và có giao thức riêng để vào đó query. Mặc định của window là của cloudflare (1.1.1.1) vì thế các bạn có thể hiểu tại sao chúng ta không cần cấu hình dns mà vẫn có thể truy cập vào google, facebook các kiểu được.
Các bạn có thể tự host dns server ở linux bằng cách sử dụng bind9 hoặc các bạn có thể sử dụng window server để set up dịch vụ DNS nhé. Ngoài ra ở trên cloud chúng ta có route53, nhưng mà route 53 hơi khác tí. Đây là sự kết hợp giữa loadbalancer và DNS, nghĩa là ngoài DNS ra, nó còn có các policy nằm phân giải một DNS ra nhiều server khác nhau nữa.
Ngoài lề tí, chúng ta có sự kết hợp độc đáo giữa DNS Server và Certificate Authority. Nghĩa là Certificate Authority sẽ tạo một key sau đó lưu vào trong database của DNS server nhằm xác thực rằng cái cặp key ssl/tls của cái Certificate authority này chỉ thuộc về DNS server đó thôi. Nghĩa là chỉ có domain thuộc DNS server đó mới được xài key từ certificate authority này ký.
Các bạn có thể test sự kết hợp này bằng cách sử dụng ACM để validate route53 ở aws. Hoặc dùng certbot để tạo ra record txt rồi validate ở route53 cũng được, nhưng đừng quên rằng là phải tạo record public và có domain add vào route53 này nhé.
SSL OffLoading or SSL termination:
Nghĩa là một đối tượng nào đó được sử dụng để chịu trách nhiệm mã hóa để nhằm giảm tải cho phái backend. Chúng ta có thể cấu hình một proxy nào đó chịu trách nhiệm xử lý DNS và server khi gửi gói tin ra ngoài mạng internet thì phải trải qua cái server proxy này. Chúng ta có thể dùng ALB hay nginx để ofloading cũng được.
Istio
Như mình nói ở trên, việc một con ALB nghĩa là traffic giao tiếp với nhau trước khi đi qua ALB nó có thể không được mã hóa và gặp nguy hiểm. MÌnh sẽ lấy ví dụ về k8s. Chúng ta có app nằm trong container, thì traffic sẽ đi ra container này giao tiếp với container khác có thể không được mã khóa, khi nào đi ra tới tầng ALB mới được mã hóa, về lý thuyết vẫn có risk nếu như hacker xâm nhập được vào bên trong hệ thống là chúng ta bị lộ thông tin. Chúng ta có thể giải quyết bằng cách add rất nhiều certificate này và việc này rất tốn công và làm phức tạp hóa backend. Vì thế istio ra đời như một cách để giải quyết. Istio chủ yếu có control plane và các side car. Side car là gì, nghĩa là chúng ta deploy container chung một pod. Control plane sẽ route và điều phối cấu hình các  side car container. Và các side car proxy này có hỗ trợ mã hóa. Từ đó ở phần backend chúng ta chỉ tập trung vào phần viết code.
Ở aws chúng ta có dịch vụ aws app mesh liên quan tới dịch vụ istio này.
----------------------------------
Bài viết đến đây cũng dài rồi nên mình xin phép kết thúc tại đây. Nếu có sai sót nhờ các bác góp ý giúp em với nhé. Ngoài ra, các bác có thuật ngữ nào hay thì đừng ngần ngại chia sẻ dưới phần comment ạ.
